## 1463. 1로 만들기

### 문제

정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.

정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

### 입력

첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.

### 출력

첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

```python
def sol():
    for i in range(2, x + 1):
        memo[i] = memo[i - 1] + 1
        if i % 2 == 0:
            if memo[i] > memo[i // 2] + 1:
                memo[i] = memo[i // 2] + 1
        if i % 3 == 0:
            if memo[i] > memo[i // 3] + 1:
                memo[i] = memo[i // 3] + 1


x = int(input())
memo = [0] * 1000001
memo[1] = 0
sol()
print(memo[x])
```

---

### 구현 과정

- 에라토스테네스의 체를 응용해서 접근해봄

  - 2 ~ 9 구간에 최소 변환 횟수를 계산
  - 구구단의 2 * n 이라면 2 - 9 구간에 + 1을 해주면 답을 유추할 수 있음
  - 구구단에 해당하는 수들에 대해서는 답 리스트를 추출할 수 있으나, 1일 빼는 연산을 계산하지 못함
  - 또한 이러한 논리는 반례가 존재
    - 예시) 10 : 2 * 5, 5의 경우 3회에 걸쳐 1 만들기 가능
    - 위의 논리라면 3회에 걸쳐 만든 5 * 2이니 10은 4회가 나와야 함
    - 하지만 10 - 1 / 3 / 3 으로 3회 만에 가능

- 반례가 존재하기에 다른 접근 방식을 이용하고자 함

- 예전에 풀이했던 색종이 오려 붙히기(?) 문제와 위 문장 `2*n 이라면 2-9 구간에 +1 해주면` 에서 점화식을 통해 메모이제이션 방법으로 접근

- x가 6일 때 나올 수 있는 경우의 수는 3가지

  1. f(6) = f(6 - 1) + 1

  2. f(6) = f(6 / 2) + 1
  3. f(6) = f(6 / 3) + 1

  > `f()`는 1로 만들기까지의 횟수를 도출하는 함수라고 가정

- 이때 2번과 3번 케이스는 조건(**2 또는 3으로 나누었을 때 나머지가 0이여야 함**)이 붙기에 조건문 추가

- 그렇게 위의 예시를 이어 가면 다음의 경우의 수끼리 비교를 하여 작은 횟수를 채택하면 된다.

  - 숫자 5에서 6으로 가는 방법 (빼기 1)     : f(5) = ... **3**
  - 숫자 3에서 6으로 가는 방법 (나누기 2) : f(3) = ... **1**
  - 숫자 2에서 6으로 가는 방법 (나누기 3) : f(2) = ... **1**

- 결국 f(6)은 최소 **2**회만에 1로 만들수 있다.



- 숫자 X의 범위가 1 <= X <= 10^6 이므로 리스트 `memo` 의 길이를 1000001로 설정한다.
- 숫자 1은 0값으로 초기화 하고 `for` 반복을 2부터 x+1 까지 순회
- 반복문이 종료된 후에 `memo[x]` 에 1로 만들기 위한 최소의 횟수가 모든 비교를 통해서 저장되어 있음



```
# input
2

# output
1
```

```
# input
10

# output
3
```

