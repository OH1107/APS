# 동전 1

| 시간 제한               | 메모리 제한 | 제출  | 정답  | 맞은 사람 | 정답 비율 |
| :---------------------- | :---------- | :---- | :---- | :-------- | :-------- |
| 0.5 초 (추가 시간 없음) | 4 MB        | 34649 | 15227 | 11335     | 44.055%   |

## 문제

n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.

사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.

## 입력

첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.

## 출력

첫째 줄에 경우의 수를 출력한다. 경우의 수는 231보다 작다.

## 예제 입력 1 복사

```
3 10
1
2
5
```

## 예제 출력 1 복사

```
10
```

---

```python
n, k = map(int, input().split())
coin = [int(input()) for _ in range(n)]

dp = [0] * (k+1)
dp[0] = 1

for i in coin:
    for j in range(i, k+1):
        dp[j] += dp[j-i]
    # print(dp)

print(dp[k])
```

- 동적계획법 (DP) 문제
  - 전체의 문제를 부분 문제로 해결하기
  - 부분 문제로 접근하며 점화식 세우기
  - 부분 문제들에 대해 얻는 결과값 메모이제이션



- '가치의 합이 `k`원이 되는 경우의 수'를 구하는 전체 문제를 '가치의 합이 `i`원이 되는 경우의 수'를 구하는 부분 문제로 접근
- 시간 제한, 메모리를 감안하여 하나의 리스트 안에서 덮어 씌우는 식으로 해결한다.



- 합이 `i`원이 되는 경우의 수를 구하기 위해 리스트 `dp`에 0을 `k+1` 만큼 초기화
  - `dp[1]`은 합이 1원이 되는 경우의 수, `dp[2]`는 합이 2원이 되는 경우의 수, ...
- `dp[0]`은 합이 0원이 되는 경우의 수가 아닌, **동전이 하나로 사용하며 시작하는 경우의 수로 이용하기 위해 ** 1로 초기화
- 첫 반복문에서 각 동전의 모든 종류를 순회
  - 1원, 2원, 5원 순서로
- 두번째 반복문은 `dp`리스트를 순회하며 특정 가치를 가진 동전을 썼을 때 합이 `j`원이 되는 경우의 수가 있다면 리스트 `dp`에 새로 기록하기 위한 반복문
  - 동전이 5원짜리라면, 1원 ~ 4원까지는 고려할 필요가 없으므로 `dp[5]`부터 순회
- 다음과 같이 `dp`배열이 채워질 것이다.

|      | 0원  | 1원  | 2원   | 3원  | 4원   | 5원   | 6원   | 7원   | 8원   | 9원   | 10원   |
| ---- | ---- | ---- | ----- | ---- | ----- | ----- | ----- | ----- | ----- | ----- | ------ |
| 1원  | 1    | 1    | 1     | 1    | 1     | 1     | 1     | 1     | 1     | 1     | 1      |
| 2원  | 1    | 1    | **2** | 2    | **3** | 3     | **4** | 4     | **5** | 5     | **6**  |
| 5원  | 1    | 1    | 2     | 2    | 3     | **4** | **5** | **6** | **7** | **8** | **10** |

- 1원만으로 만드는 경우의 수부터 시작하면,
  - `i = 1`, `j`는 `i`부터 시작하므로 가장 처음 나오는 1이다.
  - `j - i`는 0이므로 `dp[1]`에는 1이 저장될 것이다.
- 2원짜리 동전으로 넘어가면
  - `dp[2] = dp[2] + dp[0]`이다.
    - 이 뜻은 2원을 만들기 위해서는 **1원으로 만들 수 있는 경우의 수 + 2원짜리 동전 하나만을 쓰는 경우의 수**이므로 2가 된다.
  - 3원을 만들때 `dp[3] = dp[3] + dp[1]`이 된다.
    - **1원짜리 동전으로 3원을 만드는 경우의 수(1+1+1) + 1원짜리 동전으로 1원의 합을 만드는 경우에 2를 더해서 만드는 경우의 수 (1+2)**
- `dp`를 완성하고 `dp[k]`를 출력한다.