## 문제

LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.

## 입력

첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.

## 출력

첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.

## 예제 입력 1 복사

```
ACAYKP
CAPCAK
```

## 예제 출력 1 복사

```
4
```

---

```python
s1 = input()
s2 = input()

dp = [[0] * (len(s1) + 1) for _ in range(len(s2) + 1)]

for i in range(1, len(s2) + 1):
    for j in range(1, len(s1) + 1):
        if s1[j-1] == s2[i-1]:
            dp[i][j] = dp[i-1][j-1] + 1
        else:
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])

print(dp[-1][-1])
```

- LCS(Longest Common Subsequence) 문제 이해하는게 어려웠다.
  - **ACAYKP**, **CAPCAK** 두 문장의 sub sequence 중 가장 긴 길이를 구하는 문제
  - 즉, 연속성 상관없이 순서만  맞게 이어지는 문자열의 최장 길이
  - 위의 두 문자열의 LCS는 **ACAK**가 되겠다.



- `s2`, `s1` 두 문자열을 하나씩 늘려가며 모든 비교를 해보겠다.

  - `s2` : **C**
  - `s1`: **A**
    - 최장 LCS의 길이 : 0

  <br>

  - `s2` : **C**
  - `s1`: **AC**
    - 최장 LCS의 길이 : 1
    - **C**가 두 문자열의 sub sequence 이므로..

  <br>

  - `s2` : **C**
  - `s1`: **ACA**
    - 최장 LCS의 길이 : 1
    - **A** 하나가 더 추가 되었지만, **C**만이 두 문자열의 sub sequence 이므로...

  <br>

  - `s2` : **C**
  - `s1`: **ACAY** ...
  - `s1`의 끝까지 비교가 완료되면, `s2`도 한 글자씩 늘려가며 모두 비교를 진행한다.

  <br>

  - `s2` : **CA**
  - `s1`: **A**
    - 최장 LCS의 길이 : 1
    - **A**가 두 문자열의 sub sequence 이므로..

  <br>

  - `s2` : **CA**
  - `s1`: **AC**
    - 최장 LCS의 길이 : 1
    - **C** 하나가 더 추가 되었지만, **A**만이 두 문자열의 sub sequence 이므로...

  <br>

  - `s2` : **CA**
  - `s1`: **ACA**
    - 최장 LCS의 길이 : 2
    - **A**가 추가 되면서 **CA**가 sub sequence가 되었으므로



- 위 과정을 두 문자열의 모든 문자를 비교하며 진행한다.

  - 이 때, 표를 만들어 LCS값이 증가하는 방식을 보면 다음과 같이 풀어 낼 수 있다.

    |       |  -   |  C   |  A   |  P   |  C   |  A   |  K   |
    | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
    | **-** |  0   |  0   |  0   |  0   |  0   |  0   |  0   |
    | **A** |  0   |  0   |  1   |  1   |  1   |  1   |  1   |
    | **C** |  0   |  1   |  1   |  1   |  2   |  2   |  2   |
    | **A** |  0   |  1   |  2   |  2   |  2   |  3   |  3   |
    | **Y** |  0   |  1   |  2   |  2   |  2   |  3   |  3   |
    | **K** |  0   |  1   |  2   |  2   |  2   |  3   |  4   |
    | **P** |  0   |  1   |  2   |  3   |  3   |  3   |  4   |

  <br>

  - `s1`과 `s2`에 가장 최근에 추가된 글자가 서로 같다면,
    - 마지막 두 글자가 추가되기 전 가장 큰 길이의 + 1 길이가 됨
  - 추가된 글자가 서로 다르다면
    - `s1`에서 추가된 글자로 인해 생성된 LCS의 길이와 `s2`에서 추가된 글자로 인해 생성된 LCS의 길이를 비교하여 최대 길이를 갖게 됨

- 모든 표를 채우고 마지막 값을 출력하면 최장 길이를 구할 수 있음

