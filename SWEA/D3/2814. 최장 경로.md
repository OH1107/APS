## 2814. 최장 경로

N개의 정점과 M개의 간선으로 구성된 가중치가 없는 무방향 그래프에서의 최장 경로의 길이를 계산하자.

정점의 번호는 1번부터 N번까지 순서대로 부여되어 있다.

경로에는 같은 정점의 번호가 2번 이상 등장할 수 없으며, 경로 상의 인접한 점들 사이에는 반드시 두 정점을 연결하는 간선이 존재해야 한다.

경로의 길이는 경로 상에 등장하는 정점의 개수를 나타낸다.


**[입력]**

첫 번째 줄에 테스트 케이스의 수 T가 주어진다.

각 테스트 케이스의 첫 번째 줄에는 두 개의 자연수 N M(1 ≤ N ≤ 10, 0 ≤ M ≤ 20)이 주어진다.

두 번째 줄부터 M개의 줄에 걸쳐서 그래프의 간선 정보를 나타내는 두 정수 x y(1 ≤ x, y ≤ N)이 주어진다.

x와 y는 서로 다른 정수이며, 두 정점 사이에 여러 간선이 존재할 수 있다.


**[출력]**

각 테스트 케이스마다 ‘#x ’(x는 테스트케이스 번호를 의미하며 1부터 시작한다)를 출력하고, 그래프에서의 최장 경로의 길이를 출력한다.



```python
def dfs(v, l):          # 시작 노드, 탐색 거리
    global res          # 최장 거리를 저장할 변수
    visited[v] = 1      # 시작 지점의 방문 표시

    if res < l:         # 기존 저장된 최장거리보다 더 긴 거리를 발견할 경우
        res = l         # 새로운 최장 거리로 대체

    for i in range(n+1):                    # 정점 번호만큼 순회
        if adj[v][i] and not visited[i]:    # v 정점에 대해 인접하고, 방문하지 않은 정점 i에 대해서
            dfs(i, l+1)                     # dfs 탐색, 거리 + 1

    visited[v] = 0                          # 탐색이 종료되면 해당 정점은 방문 표시 취소


for tc in range(1, int(input())+1):
    n, m = map(int, input().split())


    adj = [[0] * (n+1) for _ in range(n+1)]
    visited = [0] * (n+1)
    res = 0

    for _ in range(m):                      # 인접 행렬 선언
        n1, n2 = map(int, input().split())
        adj[n1][n2] = 1
        adj[n2][n1] = 1

    for i in range(n):
        dfs(i, 1)

    print(f'#{tc} {res}')
```

```
# input
2
1 0
3 2
1 2
3 2

# output
#1 1
#2 3
```

