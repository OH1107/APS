## 1224. [S/W 문제해결 기본] 6일차 - 계산기3

문자열로 이루어진 계산식이 주어질 때, 이 계산식을 후위 표기식으로 바꾸어 계산하는 프로그램을 작성하시오.

예를 들어

“3+(4+5)*6+7”

라는 문자열로 된 계산식을 후위 표기식으로 바꾸면 다음과 같다.

"345+6*+7+"

변환된 식을 계산하면 64를 얻을 수 있다.

문자열 계산식을 구성하는 연산자는 +, * 두 종류이며 문자열 중간에 괄호가 들어갈 수 있다.

이 때 괄호의 유효성 여부는 항상 옳은 경우만 주어진다.

피연산자인 숫자는 0 ~ 9의 정수만 주어진다.

**[입력]**

각 테스트 케이스의 첫 번째 줄에는 테스트 케이스의 길이가 주어진다. 그 다음 줄에 바로 테스트 케이스가 주어진다.

총 10개의 테스트 케이스가 주어진다.

**[출력]**

\#부호와 함께 테스트 케이스의 번호를 출력하고, 공백 문자 후 답을 출력한다.

```python
t = 0
while t < 10:
    n = int(input())
    text = input()

    # 후위표현식으로 바꿔주기 위한 준비
    op_order = {"+": 1, "*": 2, "(": 0}     # 연산자의 우선 순위 설정
    res = ''                                # 후위표현식 초기화
    s = []                                  # 연산자 저장 스택

    # 중위표현식 순회
    for i in range(n):

        # 소괄호를 만날 경우
        if text[i] == '(' or text[i] == ')':
            if text[i] == '(':  # 열린 소괄호면 걍 스택에 바로 추가
                s.append(text[i])
            else:               # 닫힌 소괄호면 열린거 만날때까지 연산자들 스택에서 다 꺼내
                while s[-1] != '(':
                    res += s.pop()
                s.pop()         # 그럼 top에 여는 소괄호일건데, 그거 버려

        # 숫자 만날 경우
        elif text[i].isdigit():
            res += text[i]      # 바로 후위표현식에 추가

        # 연산자일 경우
        else:
            # 스택에 쌓인게 있으면
            if len(s) > 0:
                # push 할 연산자보다 top의 연산자 우선순위가 더 높으면 pop으로 뽑아냄
                while op_order[s[-1]] >= op_order[text[i]]:
                    res += s.pop()
                    if len(s) == 0:
                        break
                s.append(text[i])       # 우선순위 정리했으면 push

            # 스택에 쌓인거 없으면 걍 바로 추가
            else:
                s.append(text[i])

    # print(res)

    # 후위표현식 연산을 위한 준비
    s2 = []     # 숫자 담을 스택

    # 후위표현식 순회
    for i in range(len(res)):
        # 숫자면 바로 스택에 추가
        if res[i].isdigit():
            s2.append(res[i])

        # 연산자일 경우
        else:   # 스택에서 숫자를 꺼내 연산 준비
            num2 = int(s2.pop())
            num1 = int(s2.pop())

            # + 연산 후 다시 스택에 추가
            if res[i] == '+':
                s2.append(num1 + num2)

            # * 연산 후 다시 스택에 추가
            elif res[i] == '*':
                s2.append(num1 * num2)

    # 문제에 항상 옳은 경우만 주어진다고 했으니, 연산이 끝나고 마지막 숫자 하나가 스택에 남아있을 것
    ans = s2.pop()      # 그 놈이 계산완료한 값

    print('#{} {}'.format(t+1, ans))
    t += 1
```

```
# input
113
(9+(5*2+1)+(3*3*7*6*9*1*7+1+8*6+6*1*1*5*2)*4*7+4*3*8*2*6+(7*8*4*5)+3+7+(2+6+5+1+7+6+7*3*(6+2)+6+6)*2+4+2*2+4*9*3)
85
(4+8+4*(8*5*(7*(6*8)+3+(6+(3+7+1*7*5*4)*3)*2*3+5)+6+7*7)*4+2+9*4+7+2*3*(7*6*1*8)+9+9)
...

# output
#1 672676
#2 1974171
...
```

